# Наследование
> Принцип ООП где мы можем унаследоватьБпереопределять и использовать все аттрибуты и методы родительского класса

``` py
class A:
    def method(self):
        print("Метод в классе А")

obj_a = A()
obj_a.method()
# Метод в классе А

class B(A):
    pass


obj_b = B()
obj_b.method()
# Metод в классе А
```

> класс А - родительский
> класс В - дочерний

## Переопределение
> когда мы создаем метод или аттрибут  с таким же названием , как и в родительскии классах
``` py
class C(A):
    def method(self):
        print("Метод в классе С")

obj_c = C()
obj_c.method()
# Метод в классе С

```

## Виды наследование 
* **одиночное** ( когда один родитель)
* **множественное** (когда несколько родителей)
* многоуровненое (когда у родителей есть родители)
* иерархическое (когда у каждого есть только один родитель, но у родителя может быть много детей)
* гибридное (совмещение разных видов наследования )


## Проблемы множественного наследования
1. Проблема ромба (решенная с помощью MRO (с версии 2.3))
> MRO - method resolution order (простраивает порядок для поиска аттрибутов)

```py
class A: 
    pass
class B:
    pass
class C(A,B):
    pass

# до mro
[C, A, object, C, B, object]

# после mro
[C, A, B, object]

2. Проблема перекрестного наследования (не решенная, вознткает когда не возможно построит приоритет родителей)

``` py
class A:
    pass

class B:
    pass
class C(A,B):
    pass
class D(B,A):
    pass
class E(C,D):
    pass
#TypeError: Cannot create a consistent method resolution
#order (MRO) for bases A, B
```

